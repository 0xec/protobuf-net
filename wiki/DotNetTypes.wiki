#summary Suggested practice for handling additional .NET types

= Introduction =

(caveat; this is a discussion document, and only represents my own initial thoughts; it is not *in any way* an official document!)

While the .proto encoding document covers many of the primative data types, it does not provide for the constructed .NET data types such as `DateTime`, `Decimal`, etc. This document discusses some options for encoding such data.

== [http://msdn.microsoft.com/en-us/library/system.guid.aspx Guid] ==

A `Guid` is a 128-bit integer, with fairly uniform distribution; as such no "clever" encoding is possible. It is suggested to use the string wire-type (bytes .proto type) to represent the data. An encoded value would always take 17 bytes: 1 byte for the length prefix (always 16), and 16 bytes for the data.

=== Range ===

The range for `Guid` is not affected.

== Aside: Aim Variant ==

It is important to retain compatibility with the existing wire-types, so that any client can at least process/round-trip a message without error; and even if the serialization core doesn't understand any extra encoding, it can still be applied post-deserialization.

To enable this, both `Decimal` and `DateTime` are presented using the variant wire-type (int64 / sint64 .proto types). Both proposals pack additional data into the low bits of the value, restricting the overall range. Additionally note that care must be taken not to lose the sign (nor propegate the sign incorrectly) by shifting.

Note also that for signed data, this extra packing happens before zigzag encoding when serializing, and after zigzag decoding when deserializing; this allows existing zigzag / base-128 code to be used without modification.

== [http://msdn.microsoft.com/en-us/library/system.decimal.aspx Decimal] ==

A `Decimal` is comparable to IEEE 754 floating-point numbers, except a decimal base is used. This makes it suitable for holding values like money, where decimal rounding rules are expected (IEEE 754 values, on the other-hand, cannot represent many simple-looking decimal values exactly).

A typical `Decimal` value might be:

123.45

A simple option would be to encode with fixed precision; say 4 digits; this would then be encoded as the integer 1234500 and adjusted during (de)deserialization. However, this does not do justice to the full range of decimal values: since decimal is still a floating-point type, it can accurately hold values such as:

0.0000012345

As such, the proposed scheme is to pack the scale (number of decimal digits) as an integer (0-15) in the first 4 low bits of the value. So:

  * 123.45 is encoded as 12345 with scale 2: (12345 << 4) | 2 = 197522
  * 0.0000012345 is encoded as 12345 with scale 10: (12345 << 4) | 10 = 197530

Both signed and unsigned variant encodings should be supported. For efficiency, any redundant scale information should be discarded; for example a `Decimal` may hold "0.400", which is 400 with a scale of 3; but this should be encoded as 4 with a scale of 1.

=== Range ===

This allows a good range of typical decimal values to be encoded making good use of variant encoding, and without the expense of fixed-point. Note, however, that this still only leaves 60 bits of data for the value; `Decimal` itself allows 96 bits for the value, and a scale in the range 0-28; so the range of variant encoded values is limited by necessity.

For the _full_ range of values (rarely used in practice) it may be desirable to optionally offer a full-width representation via the bytes/string types: this would comprise 14 bytes:

  * 1 byte for the length prefix (always 13)
  * 1 byte for the scale and sign (scale in the low 5 bytes; sign in the high byte)
  * 12 bytes for the value

The layout is explained more [http://msdn.microsoft.com/en-us/library/system.decimal.aspx here]; note that for .NET usage this data can obtained via [http://msdn.microsoft.com/en-us/library/system.decimal.getbits.aspx GetBits], and re-combined with one of two custom constructors ([http://msdn.microsoft.com/en-us/library/t1de0ya1.aspx here] and [http://msdn.microsoft.com/en-us/library/bb1c1a6x.aspx here]).

== [http://msdn.microsoft.com/en-us/library/system.datetime.aspx DateTime] ==

A `DateTime` represents both date and time information to a precision of ticks, but in reality most `DateTime`s are actually just entire days, or a date plus a time (to the second). To capitalise on this knowledge, it is proposed to pack a scale marker into the low two bits of the value:

  * 0 = days
  * 1 = seconds
  * 2 = milliseconds
  * 3 = (not used)

The value to encode is the difference (in the appropriate scale) between the value and the unix-time origin (01-01-1970). So the date 01 Jan 2008 can be encoded as:

  * delta = 13879 days; (13879 << 2) | 0 = 55516

The most appropriate scale should be determined by inspection of the value. Additionally, note that `DateTime.MaxValue` is "all the 9s" (including below the millisecond level). To allow efficient round-trip of such values, "01-01-10000" (or rather, 2932897 on a scale of days) shall be equiavalent to `DateTime.MaxValue` in either direction. No such treatment is necessary for `DateTime.MinValue`.

=== Range ===

The full range of `DateTime` can be encoded, but not to tick precision.

== [http://msdn.microsoft.com/en-us/library/system.uri.aspx Uri] ==

A `Uri` represents a regular uri/url, but with additional support for inspecting the value and crating relative values.

`Uri` values should be treated as strings, using [http://msdn.microsoft.com/en-us/library/system.uri.tostring.aspx ToString] and the comparable [http://msdn.microsoft.com/en-us/library/z6c2z492.aspx constructor].

=== Range ===

The range for `Uri` is not affected.